/*******************************************************************************
 * Copyright (c) 2024 DFKI.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     DFKI - Tapanta Bhanja <tapanta.bhanja@dfki.de>
 *******************************************************************************/ 
package aasmyasset.module.submodels.basic;

import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.List;

import java.math.BigInteger; 

import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.Duration;
import javax.xml.namespace.QName;

import aasmyasset.connection.ConnectedDevices;
//import aasmyasset.connection.DataCrawler;
import aasmyasset.module.AASServer;
import aasmyasset.module.ConceptDescriptions;
import aasmyasset.connection.OpcUaVariable;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.Operation;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.SubmodelElementCollection;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.valuetype.ValueType;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.File;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.Property;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.MultiLanguageProperty;
import org.eclipse.basyx.submodel.metamodel.map.qualifier.LangStrings;
import org.eclipse.basyx.submodel.metamodel.map.reference.Key; 
import org.eclipse.basyx.submodel.metamodel.map.reference.Reference; 
import org.eclipse.basyx.submodel.metamodel.api.reference.IKey;
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyElements; 
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyType; 
import org.eclipse.basyx.submodel.metamodel.api.identifier.IdentifierType;
import org.eclipse.basyx.submodel.metamodel.api.qualifier.haskind.ModelingKind;
import org.eclipse.basyx.submodel.metamodel.api.submodelelement.ISubmodelElement;
import org.eclipse.basyx.submodel.metamodel.map.Submodel;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.OperationVariable;
import com.festo.aas.p4m.connection.ValueDelegate; 
import org.eclipse.basyx.vab.protocol.opcua.types.NodeId;
import org.eclipse.basyx.vab.protocol.opcua.types.UnsignedShort;
import com.festo.aas.p4m.connection.ConnectedProperty;

/**
 * 
 * @author DFKI
 * 
 * Do not edit this file for changing operation behaviours. 
 */

public class Basic extends Submodel {

	/**
	 * This field variable holds all configured connectors to the asset. 
	 * Use these connectors to communicate with your asset.
	 */
	private ConnectedDevices connectedDevices;

	private ConceptDescriptions conceptDescriptions;

	/**
     * This class contains all user-provided code for operations.
     */
	private final DynamicElementsWorkspace dew; 

	 /**
     * This class contains all user-provided code for value delegates.
     */

	 /**
     * The following contains the declaration of the operation variables as field variables so that they can be accessed in their true sense.
     */
	protected static Property Basic_IntegerA_Addition_Input = new Property("IntegerA", ValueType.Integer);
	protected static Property Basic_IntegerB_Addition_Input = new Property("IntegerB", ValueType.Integer);
		

	protected static Property Basic_name_Print_Input = new Property("name", ValueType.String);
		

	protected static Property Basic_FloatA_Subtraction_Input = new Property("FloatA", ValueType.Float);
	protected static Property Basic_FloatB_Subtraction_Input = new Property("FloatB", ValueType.Float);
		



	public Basic() {

		try {
			connectedDevices = new ConnectedDevices();
		} 
		catch (Exception e) {

			e.printStackTrace();
		}
		
		dew = new DynamicElementsWorkspace(connectedDevices);
		conceptDescriptions = new ConceptDescriptions();

		setIdShort("Basic");
		setIdentification(IdentifierType.IRI, AASServer.getSettings().SUBMODEL_BASIC_IRI.get().toString()); 
		setKind(ModelingKind.INSTANCE); 
		List<IKey> basicKeys= new ArrayList<IKey>();
		Reference BasicRef = new Reference(basicKeys);
		setSemanticId(BasicRef); 
 
		Function<Object[], Object> callBasic_SayHello = (arguments) -> {

			dew.Basic_SayHello();
			return null;

		};
		Operation Basic_SayHello= new Operation();
		Basic_SayHello.setIdShort("SayHello");
		Basic_SayHello.setInvokable(callBasic_SayHello);
		Basic_SayHello.setKind(ModelingKind.INSTANCE);
		List<IKey> Basic_sayhelloKeys= new ArrayList<IKey>();
		Reference Basic_SayHelloRef = new Reference(Basic_sayhelloKeys);
		Basic_SayHello.setSemanticId(Basic_SayHelloRef); 
 
		addSubmodelElement(Basic_SayHello);





		Function<Object[], Object> callBasic_Addition = (arguments) -> {

			Basic_IntegerA_Addition_Input.setValue((arguments[0]));
			Basic_IntegerB_Addition_Input.setValue((arguments[1]));
			dew.Basic_Addition((BigInteger) Basic_IntegerA_Addition_Input.getValue(),(BigInteger) Basic_IntegerB_Addition_Input.getValue());
			return null;

		};
		Operation Basic_Addition= new Operation();
		Basic_Addition.setIdShort("Addition");
		Basic_Addition.setInvokable(callBasic_Addition);
		Basic_Addition.setKind(ModelingKind.INSTANCE);
		List<IKey> Basic_additionKeys= new ArrayList<IKey>();
		Reference Basic_AdditionRef = new Reference(Basic_additionKeys);
		Basic_Addition.setSemanticId(Basic_AdditionRef); 
 
		addSubmodelElement(Basic_Addition);

		Collection<OperationVariable> Basic_AdditionInputs = new ArrayList<OperationVariable>();
		OperationVariable Basic_IntegerAAddition = new OperationVariable();
		Basic_IntegerA_Addition_Input.setKind(ModelingKind.TEMPLATE);
		Basic_IntegerAAddition.setValue(Basic_IntegerA_Addition_Input);
		Basic_AdditionInputs.add(Basic_IntegerAAddition);
		Basic_Addition.setInputVariables(Basic_AdditionInputs); 
		OperationVariable Basic_IntegerBAddition = new OperationVariable();
		Basic_IntegerB_Addition_Input.setKind(ModelingKind.TEMPLATE);
		Basic_IntegerBAddition.setValue(Basic_IntegerB_Addition_Input);
		Basic_AdditionInputs.add(Basic_IntegerBAddition);
		Basic_Addition.setInputVariables(Basic_AdditionInputs); 




		Function<Object[], Object> callBasic_Print = (arguments) -> {

			Basic_name_Print_Input.setValue((arguments[0]));
			dew.Basic_Print((String) Basic_name_Print_Input.getValue());
			return null;

		};
		Operation Basic_Print= new Operation();
		Basic_Print.setIdShort("Print");
		Basic_Print.setInvokable(callBasic_Print);
		Basic_Print.setKind(ModelingKind.INSTANCE);
		List<IKey> Basic_printKeys= new ArrayList<IKey>();
		Reference Basic_PrintRef = new Reference(Basic_printKeys);
		Basic_Print.setSemanticId(Basic_PrintRef); 
 
		addSubmodelElement(Basic_Print);

		Collection<OperationVariable> Basic_PrintInputs = new ArrayList<OperationVariable>();
		OperationVariable Basic_namePrint = new OperationVariable();
		Basic_name_Print_Input.setKind(ModelingKind.TEMPLATE);
		Basic_namePrint.setValue(Basic_name_Print_Input);
		Basic_PrintInputs.add(Basic_namePrint);
		Basic_Print.setInputVariables(Basic_PrintInputs); 




		Function<Object[], Object> callBasic_Subtraction = (arguments) -> {

			Basic_FloatA_Subtraction_Input.setValue((arguments[0]));
			Basic_FloatB_Subtraction_Input.setValue((arguments[1]));
			dew.Basic_Subtraction((Float) Basic_FloatA_Subtraction_Input.getValue(),(Float) Basic_FloatB_Subtraction_Input.getValue());
			return null;

		};
		Operation Basic_Subtraction= new Operation();
		Basic_Subtraction.setIdShort("Subtraction");
		Basic_Subtraction.setInvokable(callBasic_Subtraction);
		Basic_Subtraction.setKind(ModelingKind.INSTANCE);
		List<IKey> Basic_subtractionKeys= new ArrayList<IKey>();
		Reference Basic_SubtractionRef = new Reference(Basic_subtractionKeys);
		Basic_Subtraction.setSemanticId(Basic_SubtractionRef); 
 
		addSubmodelElement(Basic_Subtraction);

		Collection<OperationVariable> Basic_SubtractionInputs = new ArrayList<OperationVariable>();
		OperationVariable Basic_FloatASubtraction = new OperationVariable();
		Basic_FloatA_Subtraction_Input.setKind(ModelingKind.TEMPLATE);
		Basic_FloatASubtraction.setValue(Basic_FloatA_Subtraction_Input);
		Basic_SubtractionInputs.add(Basic_FloatASubtraction);
		Basic_Subtraction.setInputVariables(Basic_SubtractionInputs); 
		OperationVariable Basic_FloatBSubtraction = new OperationVariable();
		Basic_FloatB_Subtraction_Input.setKind(ModelingKind.TEMPLATE);
		Basic_FloatBSubtraction.setValue(Basic_FloatB_Subtraction_Input);
		Basic_SubtractionInputs.add(Basic_FloatBSubtraction);
		Basic_Subtraction.setInputVariables(Basic_SubtractionInputs); 




	}
	
}

